#include "BPlusTest.hpp"

void BPlusTest::test_nodes(){
    std::cout << "LEAF TESTS:\n";

    BPlusTree<int,int,4> tree4;
    BPlusTree<int,int,5> tree5;
    tester("1. empty leaf", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf (true);
        BPlusTree<int,int,5>::BPlusNode odd_leaf (true);
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 0);
        _ASSERT(even_leaf.m_next == nullptr);
        _ASSERT(odd_leaf.m_next == nullptr);
        _ASSERT(even_leaf.m_prev == nullptr);
        _ASSERT(odd_leaf.m_prev == nullptr);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.erase(tree4,0) == false);
        _ASSERT(odd_leaf.erase(tree5,0) == false);
        even_leaf.erase_all();
        odd_leaf.erase_all();
        return passed;
    });

    tester("2. basic emplaceion", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf (true);
        BPlusTree<int,int,5>::BPlusNode odd_leaf (true);
        even_leaf.emplace(tree4,0,0);
        even_leaf.emplace(tree4,10,10);
        even_leaf.emplace(tree4,30,30);
        even_leaf.emplace(tree4,20,20);
        odd_leaf.emplace(tree5,20,20);
        odd_leaf.emplace(tree5,40,40);
        odd_leaf.emplace(tree5,30,30);
        odd_leaf.emplace(tree5,0,0);
        odd_leaf.emplace(tree5,10,10);
        
        _ASSERT(even_leaf.m_key_counter == 4);
        _ASSERT(odd_leaf.m_key_counter == 5);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);
        even_leaf.emplace(tree4,20,80);
        odd_leaf.emplace(tree5,20,80);
        _ASSERT(even_leaf.m_key_counter == 4);
        _ASSERT(odd_leaf.m_key_counter == 5);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        even_leaf.erase_all();
        odd_leaf.erase_all();
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 0);
        return passed;
    });

    tester("3. emplaceion above split", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf (true);
        BPlusTree<int,int,5>::BPlusNode odd_leaf (true);
        even_leaf.emplace(tree4,10,10);
        even_leaf.emplace(tree4,20,20);
        even_leaf.emplace(tree4,40,40);
        even_leaf.emplace(tree4,0,0);

        BPlusTree<int,int,4>::BPlusNode* new_even_leaf = even_leaf.emplace(tree4,30,30);
        _ASSERT(even_leaf.m_next == new_even_leaf);
        _ASSERT(new_even_leaf->m_prev == &even_leaf);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(((even_leaf.search(20) != nullptr) && (*(even_leaf.search(20)) == 20)) || (*(new_even_leaf->search(20)) == 20));
        _ASSERT(*(new_even_leaf->search(30)) == 30);
        _ASSERT(*(new_even_leaf->search(40)) == 40);
        even_leaf.erase_all();
        new_even_leaf->erase_all();
        delete new_even_leaf;

        odd_leaf.emplace(tree5,10,10);
        odd_leaf.emplace(tree5,20,20);
        odd_leaf.emplace(tree5,30,30);
        odd_leaf.emplace(tree5,50,50);
        odd_leaf.emplace(tree5,0,0);

        BPlusTree<int,int,5>::BPlusNode* new_odd_leaf = odd_leaf.emplace(tree5,40,40);
        _ASSERT(odd_leaf.m_next == new_odd_leaf);
        _ASSERT(new_odd_leaf->m_prev == &odd_leaf);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(new_odd_leaf->search(30)) == 30);
        _ASSERT(*(new_odd_leaf->search(40)) == 40);
        _ASSERT(*(new_odd_leaf->search(50)) == 50);
        odd_leaf.erase_all();
        new_odd_leaf->erase_all();
        delete new_odd_leaf;
        return passed;
    });

    tester("4. emplaceion below split", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf (true);
        BPlusTree<int,int,5>::BPlusNode odd_leaf (true);
        even_leaf.emplace(tree4,30,30);
        even_leaf.emplace(tree4,20,20);
        even_leaf.emplace(tree4,40,40);
        even_leaf.emplace(tree4,0,0);

        BPlusTree<int,int,4>::BPlusNode* new_even_leaf = even_leaf.emplace(tree4,10,10);
        _ASSERT(even_leaf.m_next == new_even_leaf);
        _ASSERT(new_even_leaf->m_prev == &even_leaf);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(((even_leaf.search(20) != nullptr) && (*(even_leaf.search(20)) == 20)) || (*(new_even_leaf->search(20)) == 20));
        _ASSERT(*(new_even_leaf->search(30)) == 30);
        _ASSERT(*(new_even_leaf->search(40)) == 40);
        even_leaf.erase_all();
        new_even_leaf->erase_all();
        delete new_even_leaf;

        odd_leaf.emplace(tree5,40,40);
        odd_leaf.emplace(tree5,20,20);
        odd_leaf.emplace(tree5,30,30);
        odd_leaf.emplace(tree5,50,50);
        odd_leaf.emplace(tree5,0,0);

        BPlusTree<int,int,5>::BPlusNode* new_odd_leaf = odd_leaf.emplace(tree5,10,10);
        _ASSERT(odd_leaf.m_next == new_odd_leaf);
        _ASSERT(new_odd_leaf->m_prev == &odd_leaf);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(new_odd_leaf->search(30)) == 30);
        _ASSERT(*(new_odd_leaf->search(40)) == 40);
        _ASSERT(*(new_odd_leaf->search(50)) == 50);
        odd_leaf.erase_all();
        new_odd_leaf->erase_all();
        delete new_odd_leaf;
        return passed;
    });

    tester("5. emplaceion near split", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf (true);
        BPlusTree<int,int,5>::BPlusNode odd_leaf (true);
        even_leaf.emplace(tree4,30,30);
        even_leaf.emplace(tree4,10,10);
        even_leaf.emplace(tree4,40,40);
        even_leaf.emplace(tree4,0,0);

        BPlusTree<int,int,4>::BPlusNode* new_even_leaf = even_leaf.emplace(tree4,20,20);
        _ASSERT(even_leaf.m_next == new_even_leaf);
        _ASSERT(new_even_leaf->m_prev == &even_leaf);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(((even_leaf.search(20) != nullptr) && (*(even_leaf.search(20)) == 20)) || (*(new_even_leaf->search(20)) == 20));
        _ASSERT(*(new_even_leaf->search(30)) == 30);
        _ASSERT(*(new_even_leaf->search(40)) == 40);
        even_leaf.erase_all();
        new_even_leaf->erase_all();
        delete new_even_leaf;

        odd_leaf.emplace(tree5,40,40);
        odd_leaf.emplace(tree5,10,10);
        odd_leaf.emplace(tree5,30,30);
        odd_leaf.emplace(tree5,50,50);
        odd_leaf.emplace(tree5,0,0);

        BPlusTree<int,int,5>::BPlusNode* new_odd_leaf = odd_leaf.emplace(tree5,20,20);
        _ASSERT(odd_leaf.m_next == new_odd_leaf);
        _ASSERT(new_odd_leaf->m_prev == &odd_leaf);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(new_odd_leaf->search(30)) == 30);
        _ASSERT(*(new_odd_leaf->search(40)) == 40);
        _ASSERT(*(new_odd_leaf->search(50)) == 50);
        odd_leaf.erase_all();
        new_odd_leaf->erase_all();
        delete new_odd_leaf;

        odd_leaf.m_next = nullptr; // new_odd_leaf got deleted, preventing a pointer error
        odd_leaf.emplace(tree5,40,40);
        odd_leaf.emplace(tree5,10,10);
        odd_leaf.emplace(tree5,20,20);
        odd_leaf.emplace(tree5,50,50);
        odd_leaf.emplace(tree5,0,0);

        new_odd_leaf = odd_leaf.emplace(tree5,30,30);
        _ASSERT(odd_leaf.m_next == new_odd_leaf);
        _ASSERT(new_odd_leaf->m_prev == &odd_leaf);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(new_odd_leaf->search(30)) == 30);
        _ASSERT(*(new_odd_leaf->search(40)) == 40);
        _ASSERT(*(new_odd_leaf->search(50)) == 50);
        odd_leaf.erase_all();
        new_odd_leaf->erase_all();
        delete new_odd_leaf;
        return passed;
    });

    tester("6. duplicate emplaceion", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf (true);
        BPlusTree<int,int,5>::BPlusNode odd_leaf (true);
        even_leaf.emplace(tree4,0,0);
        odd_leaf.emplace(tree5,10,10);
        
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);

        even_leaf.emplace(tree4,0,20);
        odd_leaf.emplace(tree5,10,30);
        _ASSERT(even_leaf.m_key_counter == 1);
        _ASSERT(odd_leaf.m_key_counter == 1);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);

        even_leaf.erase_all();
        odd_leaf.erase_all();
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 0);
        return passed;
    });

    tester("7. deletion", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf (true);
        BPlusTree<int,int,5>::BPlusNode odd_leaf (true);
        even_leaf.emplace(tree4,0,0);
        even_leaf.emplace(tree4,10,10);
        even_leaf.emplace(tree4,30,30);
        even_leaf.emplace(tree4,20,20);
        odd_leaf.emplace(tree5,20,20);
        odd_leaf.emplace(tree5,40,40);
        odd_leaf.emplace(tree5,30,30);
        odd_leaf.emplace(tree5,0,0);
        odd_leaf.emplace(tree5,10,10);
        
        _ASSERT(even_leaf.m_key_counter == 4);
        _ASSERT(odd_leaf.m_key_counter == 5);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase(tree4,0);
        odd_leaf.erase(tree5,0);
        _ASSERT(even_leaf.m_key_counter == 3);
        _ASSERT(odd_leaf.m_key_counter == 4);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase(tree4,10);
        odd_leaf.erase(tree5,10);
        _ASSERT(even_leaf.m_key_counter == 2);
        _ASSERT(odd_leaf.m_key_counter == 3);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        _ASSERT(even_leaf.erase(tree4,10) == false); // already erased from the subtree
        _ASSERT(odd_leaf.erase(tree5,10) == false);
        _ASSERT(even_leaf.m_key_counter == 2);
        _ASSERT(odd_leaf.m_key_counter == 3);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        _ASSERT(even_leaf.erase(tree4,90) == false); // never was in the subtree
        _ASSERT(odd_leaf.erase(tree5,90) == false);
        _ASSERT(even_leaf.m_key_counter == 2);
        _ASSERT(odd_leaf.m_key_counter == 3);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase(tree4,30);
        odd_leaf.erase(tree5,30);
        _ASSERT(even_leaf.m_key_counter == 1);
        _ASSERT(odd_leaf.m_key_counter == 2);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(even_leaf.search(30) == nullptr);
        _ASSERT(odd_leaf.search(30) == nullptr);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase(tree4,20);
        odd_leaf.erase(tree5,20);
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 1);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(even_leaf.search(20) == nullptr);
        _ASSERT(odd_leaf.search(20) == nullptr);
        _ASSERT(even_leaf.search(30) == nullptr);
        _ASSERT(odd_leaf.search(30) == nullptr);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase_all();
        odd_leaf.erase_all();
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 0);
        return passed;
    });

    std::cout << "INTERNAL NODE TESTS:\n";
    
    tester("1. search", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf_1 (true);
        even_leaf_1.emplace(tree4,0,0);
        even_leaf_1.emplace(tree4,10,10);
        even_leaf_1.emplace(tree4,30,30);
        even_leaf_1.emplace(tree4,20,20);
        BPlusTree<int,int,4>::BPlusNode even_leaf_2 (true);
        even_leaf_2.emplace(tree4,40,40);
        even_leaf_2.emplace(tree4,50,50);
        even_leaf_2.emplace(tree4,60,60);
        even_leaf_2.emplace(tree4,70,70);
        BPlusTree<int,int,4>::BPlusNode even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = &even_leaf_1;
        std::get<1>(even_node.m_data)[1] = &even_leaf_2;
        even_node.m_keys[0] = even_leaf_1.m_keys[0];
        even_node.m_keys[1] = even_leaf_2.m_keys[0];

        _ASSERT(even_node.m_key_counter == 2);
        _ASSERT(even_node.m_keys[0] == 0);
        _ASSERT(even_node.m_keys[1] == 40);
        _ASSERT(std::get<1>(even_node.m_data)[0] == &even_leaf_1);
        _ASSERT(std::get<1>(even_node.m_data)[1] == &even_leaf_2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(*(even_node.search(70)) == 70);
        _ASSERT(even_node.search(-1) == nullptr);
        even_leaf_1.erase_all();
        even_leaf_2.erase_all();

        BPlusTree<int,int,5>::BPlusNode odd_leaf_1 (true);
        odd_leaf_1.emplace(tree5,0,0);
        odd_leaf_1.emplace(tree5,10,10);
        odd_leaf_1.emplace(tree5,30,30);
        odd_leaf_1.emplace(tree5,-10,-10);
        odd_leaf_1.emplace(tree5,20,20);
        BPlusTree<int,int,5>::BPlusNode odd_leaf_2 (true);
        odd_leaf_2.emplace(tree5,40,40);
        odd_leaf_2.emplace(tree5,50,50);
        odd_leaf_2.emplace(tree5,60,60);
        odd_leaf_2.emplace(tree5,80,80);
        odd_leaf_2.emplace(tree5,70,70);
        BPlusTree<int,int,5>::BPlusNode odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = &odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = &odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1.m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2.m_keys[0];

        _ASSERT(odd_node.m_key_counter == 2);
        _ASSERT(odd_node.m_keys[0] == -10);
        _ASSERT(odd_node.m_keys[1] == 40);
        _ASSERT(std::get<1>(odd_node.m_data)[0] == &odd_leaf_1);
        _ASSERT(std::get<1>(odd_node.m_data)[1] == &odd_leaf_2);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(odd_node.search(-1) == nullptr);
        odd_leaf_1.erase_all();
        odd_leaf_2.erase_all();
        return passed;
    });

    tester("2. basic emplaceion", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf_1 (true);
        even_leaf_1.emplace(tree4,0,0);
        even_leaf_1.emplace(tree4,10,10);
        BPlusTree<int,int,4>::BPlusNode even_leaf_2 (true);
        even_leaf_2.emplace(tree4,60,60);
        even_leaf_2.emplace(tree4,70,70);
        BPlusTree<int,int,4>::BPlusNode even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = &even_leaf_1;
        std::get<1>(even_node.m_data)[1] = &even_leaf_2;
        even_node.m_keys[0] = even_leaf_1.m_keys[0];
        even_node.m_keys[1] = 40;

        even_node.emplace(tree4,30,30);
        even_node.emplace(tree4,20,20);
        even_node.emplace(tree4,40,40);
        even_node.emplace(tree4,50,50);

        _ASSERT(even_node.m_key_counter == 2);
        _ASSERT(even_node.m_keys[0] == 0);
        _ASSERT(even_node.m_keys[1] == 40);
        _ASSERT(std::get<1>(even_node.m_data)[0] == &even_leaf_1);
        _ASSERT(std::get<1>(even_node.m_data)[1] == &even_leaf_2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(*(even_node.search(70)) == 70);
        even_leaf_1.erase_all();
        even_leaf_2.erase_all();

        BPlusTree<int,int,5>::BPlusNode odd_leaf_1 (true);
        odd_leaf_1.emplace(tree5,0,0);
        odd_leaf_1.emplace(tree5,10,10);
        odd_leaf_1.emplace(tree5,30,30);
        BPlusTree<int,int,5>::BPlusNode odd_leaf_2 (true);
        odd_leaf_2.emplace(tree5,40,40);
        odd_leaf_2.emplace(tree5,50,50);
        
        BPlusTree<int,int,5>::BPlusNode odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = &odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = &odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1.m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2.m_keys[0];

        odd_node.emplace(tree5,-10,-10);
        odd_node.emplace(tree5,20,20);
        odd_node.emplace(tree5,60,60);
        odd_node.emplace(tree5,80,80);
        odd_node.emplace(tree5,70,70);

        _ASSERT(odd_node.m_key_counter == 2);
        _ASSERT(odd_node.m_keys[0] == -10);
        _ASSERT(odd_node.m_keys[1] == 40);
        _ASSERT(std::get<1>(odd_node.m_data)[0] == &odd_leaf_1);
        _ASSERT(std::get<1>(odd_node.m_data)[1] == &odd_leaf_2);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        odd_leaf_1.erase_all();
        odd_leaf_2.erase_all();
        return passed;
    });

    tester("3. emplaceion with subnode splitting", [&]{
        BPlusTree<int,int,4>::BPlusNode even_leaf_1 (true);
        even_leaf_1.emplace(tree4,0,0);
        even_leaf_1.emplace(tree4,10,10);
        even_leaf_1.emplace(tree4,30,30);
        even_leaf_1.emplace(tree4,20,20);
        BPlusTree<int,int,4>::BPlusNode even_leaf_2 (true);
        even_leaf_2.emplace(tree4,80,80);
        even_leaf_2.emplace(tree4,50,50);
        even_leaf_2.emplace(tree4,60,60);
        even_leaf_2.emplace(tree4,70,70);
        BPlusTree<int,int,4>::BPlusNode even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = &even_leaf_1;
        std::get<1>(even_node.m_data)[1] = &even_leaf_2;
        even_node.m_keys[0] = even_leaf_1.m_keys[0];
        even_node.m_keys[1] = even_leaf_2.m_keys[0];
        even_node.emplace(tree4,40,40);

        _ASSERT(even_node.m_key_counter == 3);
        _ASSERT(even_node.m_keys[0] == 0);
        _ASSERT(even_node.m_keys[2] == 50);
        _ASSERT(std::get<1>(even_node.m_data)[0] == &even_leaf_1);
        _ASSERT(std::get<1>(even_node.m_data)[2] == &even_leaf_2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(*(even_node.search(70)) == 70);
        _ASSERT(*(even_node.search(80)) == 80);
        even_leaf_1.erase_all();
        even_leaf_2.erase_all();
        std::get<1>(even_node.m_data)[1]->erase_all();
        delete std::get<1>(even_node.m_data)[1];

        BPlusTree<int,int,5>::BPlusNode odd_leaf_1 (true);
        odd_leaf_1.emplace(tree5,0,0);
        odd_leaf_1.emplace(tree5,10,10);
        odd_leaf_1.emplace(tree5,30,30);
        odd_leaf_1.emplace(tree5,-10,-10);
        odd_leaf_1.emplace(tree5,20,20);
        BPlusTree<int,int,5>::BPlusNode odd_leaf_2 (true);
        odd_leaf_2.emplace(tree5,40,40);
        odd_leaf_2.emplace(tree5,50,50);
        odd_leaf_2.emplace(tree5,60,60);
        odd_leaf_2.emplace(tree5,80,80);
        odd_leaf_2.emplace(tree5,70,70);
        BPlusTree<int,int,5>::BPlusNode odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = &odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = &odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1.m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2.m_keys[0];

        odd_node.emplace(tree5,-20,-20);
        _ASSERT(odd_node.m_key_counter == 3);
        _ASSERT(odd_node.m_keys[0] == -20);
        _ASSERT(odd_node.m_keys[2] == 40);
        _ASSERT(std::get<1>(odd_node.m_data)[0] == &odd_leaf_1);
        _ASSERT(std::get<1>(odd_node.m_data)[2] == &odd_leaf_2);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(odd_node.search(-1) == nullptr);
        odd_leaf_1.erase_all();
        odd_leaf_2.erase_all();
        std::get<1>(odd_node.m_data)[1]->erase_all();
        delete std::get<1>(odd_node.m_data)[1];
        return passed;
    });

    tester("4. emplaceion with this splitting", [&]{
        BPlusTree<int,int,4>::BPlusNode* even_leaf_1 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_1->emplace(tree4,0,0);
        even_leaf_1->emplace(tree4,10,10);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_2 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_2->emplace(tree4,30,30);
        even_leaf_2->emplace(tree4,20,20);
        even_leaf_2->emplace(tree4,40,40);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_3 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_3->emplace(tree4,50,50);
        even_leaf_3->emplace(tree4,60,60);
        even_leaf_3->emplace(tree4,70,70);
        even_leaf_3->emplace(tree4,80,80);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_4 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_4->emplace(tree4,120,120);
        even_leaf_4->emplace(tree4,100,100);
        even_leaf_4->emplace(tree4,110,110);
        BPlusTree<int,int,4>::BPlusNode even_node (false);
        even_node.m_key_counter = 4;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        std::get<1>(even_node.m_data)[2] = even_leaf_3;
        std::get<1>(even_node.m_data)[3] = even_leaf_4;
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];
        even_node.m_keys[2] = even_leaf_3->m_keys[0];
        even_node.m_keys[3] = even_leaf_4->m_keys[0];
        auto new_even_node = even_node.emplace(tree4,90,90);

        _ASSERT(1 < even_node.m_key_counter && even_node.m_key_counter < 4);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(((even_node.search(50) != nullptr) && (*(even_node.search(50)) == 50)) || (*(new_even_node->search(50)) == 50));
        _ASSERT(((even_node.search(60) != nullptr) && (*(even_node.search(60)) == 60)) || (*(new_even_node->search(60)) == 60));
        _ASSERT(((even_node.search(70) != nullptr) && (*(even_node.search(70)) == 70)) || (*(new_even_node->search(70)) == 70));
        _ASSERT(*(new_even_node->search(80)) == 80);
        _ASSERT(*(new_even_node->search(90)) == 90);
        _ASSERT(*(new_even_node->search(100)) == 100);
        _ASSERT(*(new_even_node->search(110)) == 110);
        _ASSERT(*(new_even_node->search(120)) == 120);
        even_node.erase_all();
        new_even_node->erase_all();
        delete new_even_node;

        BPlusTree<int,int,5>::BPlusNode* odd_leaf_1 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_1->emplace(tree5,-20,-20);
        odd_leaf_1->emplace(tree5,0,0);
        odd_leaf_1->emplace(tree5,-10,-10);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_2 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_2->emplace(tree5,30,30);
        odd_leaf_2->emplace(tree5,20,20);
        odd_leaf_2->emplace(tree5,10,10);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_3 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_3->emplace(tree5,50,50);
        odd_leaf_3->emplace(tree5,40,40);
        odd_leaf_3->emplace(tree5,60,60);
        odd_leaf_3->emplace(tree5,70,70);
        odd_leaf_3->emplace(tree5,80,80);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_4 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_4->emplace(tree5,120,120);
        odd_leaf_4->emplace(tree5,100,100);
        odd_leaf_4->emplace(tree5,110,110);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_5 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_5->emplace(tree5,130,130);
        odd_leaf_5->emplace(tree5,140,140);
        odd_leaf_5->emplace(tree5,150,150);
        BPlusTree<int,int,5>::BPlusNode odd_node (false);
        odd_node.m_key_counter = 5;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        std::get<1>(odd_node.m_data)[2] = odd_leaf_3;
        std::get<1>(odd_node.m_data)[3] = odd_leaf_4;
        std::get<1>(odd_node.m_data)[4] = odd_leaf_5;
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];
        odd_node.m_keys[2] = odd_leaf_3->m_keys[0];
        odd_node.m_keys[3] = odd_leaf_4->m_keys[0];
        odd_node.m_keys[4] = odd_leaf_5->m_keys[0];
        auto new_odd_node = odd_node.emplace(tree5,90,90);

        _ASSERT(1 < odd_node.m_key_counter && odd_node.m_key_counter < 4);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(new_odd_node->search(70)) == 70);
        _ASSERT(*(new_odd_node->search(80)) == 80);
        _ASSERT(*(new_odd_node->search(90)) == 90);
        _ASSERT(*(new_odd_node->search(100)) == 100);
        _ASSERT(*(new_odd_node->search(110)) == 110);
        _ASSERT(*(new_odd_node->search(120)) == 120);
        _ASSERT(*(new_odd_node->search(130)) == 130);
        _ASSERT(*(new_odd_node->search(140)) == 140);
        _ASSERT(*(new_odd_node->search(150)) == 150);
        odd_node.erase_all();
        new_odd_node->erase_all();
        delete new_odd_node;
        return passed;
    });

    tester("5. basic deletion", [&]{
        BPlusTree<int,int,4>::BPlusNode* even_leaf_1 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_1->emplace(tree4,0,0);
        even_leaf_1->emplace(tree4,10,10);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_2 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_2->emplace(tree4,30,30);
        even_leaf_2->emplace(tree4,20,20);
        even_leaf_2->emplace(tree4,40,40);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_3 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_3->emplace(tree4,50,50);
        even_leaf_3->emplace(tree4,60,60);
        even_leaf_3->emplace(tree4,70,70);
        even_leaf_3->emplace(tree4,80,80);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_4 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_4->emplace(tree4,120,120);
        even_leaf_4->emplace(tree4,100,100);
        even_leaf_4->emplace(tree4,110,110);
        BPlusTree<int,int,4>::BPlusNode even_node (false);
        even_node.m_key_counter = 4;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        std::get<1>(even_node.m_data)[2] = even_leaf_3;
        std::get<1>(even_node.m_data)[3] = even_leaf_4;
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];
        even_node.m_keys[2] = even_leaf_3->m_keys[0];
        even_node.m_keys[3] = even_leaf_4->m_keys[0];

        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(*(even_node.search(70)) == 70);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(*(even_node.search(100)) == 100);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);

        _ASSERT(even_node.erase(tree4,70) == true);
        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(std::get<1>(even_node.m_data)[2]->m_key_counter == 3);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(*(even_node.search(100)) == 100);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);

        _ASSERT(even_node.erase(tree4,100) == true);
        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(std::get<1>(even_node.m_data)[3]->m_key_counter == 2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(even_node.search(100) == nullptr);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);

        _ASSERT(even_node.erase(tree4,100) == false); // already erased from the subtree4,
        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(std::get<1>(even_node.m_data)[3]->m_key_counter == 2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(even_node.search(100) == nullptr);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);

        _ASSERT(even_node.erase(tree4,200) == false); // never was in the subtree4,
        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(std::get<1>(even_node.m_data)[3]->m_key_counter == 2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(even_node.search(100) == nullptr);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);
        even_node.erase_all();

        _ASSERT(even_node.m_key_counter == 0);
        _ASSERT(even_node.search(-20) == nullptr);
        _ASSERT(even_node.search(-10) == nullptr);
        _ASSERT(even_node.search(0) == nullptr);
        _ASSERT(even_node.search(10) == nullptr);
        _ASSERT(even_node.search(20) == nullptr);
        _ASSERT(even_node.search(30) == nullptr);
        _ASSERT(even_node.search(40) == nullptr);
        _ASSERT(even_node.search(50) == nullptr);
        _ASSERT(even_node.search(60) == nullptr);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(even_node.search(80) == nullptr);
        _ASSERT(even_node.search(90) == nullptr);
        _ASSERT(even_node.search(100) == nullptr);
        _ASSERT(even_node.search(110) == nullptr);
        _ASSERT(even_node.search(120) == nullptr);
        _ASSERT(even_node.search(130) == nullptr);
        _ASSERT(even_node.search(140) == nullptr);

        BPlusTree<int,int,5>::BPlusNode* odd_leaf_1 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_1->emplace(tree5,-20,-20);
        odd_leaf_1->emplace(tree5,0,0);
        odd_leaf_1->emplace(tree5,-10,-10);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_2 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_2->emplace(tree5,30,30);
        odd_leaf_2->emplace(tree5,20,20);
        odd_leaf_2->emplace(tree5,10,10);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_3 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_3->emplace(tree5,50,50);
        odd_leaf_3->emplace(tree5,40,40);
        odd_leaf_3->emplace(tree5,60,60);
        odd_leaf_3->emplace(tree5,70,70);
        odd_leaf_3->emplace(tree5,80,80);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_4 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_4->emplace(tree5,120,120);
        odd_leaf_4->emplace(tree5,100,100);
        odd_leaf_4->emplace(tree5,110,110);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_5 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_5->emplace(tree5,130,130);
        odd_leaf_5->emplace(tree5,140,140);
        odd_leaf_5->emplace(tree5,150,150);
        BPlusTree<int,int,5>::BPlusNode odd_node (false);
        odd_node.m_key_counter = 5;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        std::get<1>(odd_node.m_data)[2] = odd_leaf_3;
        std::get<1>(odd_node.m_data)[3] = odd_leaf_4;
        std::get<1>(odd_node.m_data)[4] = odd_leaf_5;
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];
        odd_node.m_keys[2] = odd_leaf_3->m_keys[0];
        odd_node.m_keys[3] = odd_leaf_4->m_keys[0];
        odd_node.m_keys[4] = odd_leaf_5->m_keys[0];

        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);

        _ASSERT(odd_node.erase(tree5,60) == true);
        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);

        _ASSERT(odd_node.erase(tree5,70) == true);
        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(odd_node.search(70) == nullptr);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);

        _ASSERT(odd_node.erase(tree5,70) == false);
        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(odd_node.search(70) == nullptr);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);

        _ASSERT(odd_node.erase(tree5,470) == false);
        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(odd_node.search(70) == nullptr);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);
        odd_node.erase_all();

        _ASSERT(odd_node.m_key_counter == 0);
        _ASSERT(odd_node.search(-20) == nullptr);
        _ASSERT(odd_node.search(-10) == nullptr);
        _ASSERT(odd_node.search(0) == nullptr);
        _ASSERT(odd_node.search(10) == nullptr);
        _ASSERT(odd_node.search(20) == nullptr);
        _ASSERT(odd_node.search(30) == nullptr);
        _ASSERT(odd_node.search(40) == nullptr);
        _ASSERT(odd_node.search(50) == nullptr);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(odd_node.search(70) == nullptr);
        _ASSERT(odd_node.search(80) == nullptr);
        _ASSERT(odd_node.search(90) == nullptr);
        _ASSERT(odd_node.search(100) == nullptr);
        _ASSERT(odd_node.search(110) == nullptr);
        _ASSERT(odd_node.search(120) == nullptr);
        _ASSERT(odd_node.search(130) == nullptr);
        _ASSERT(odd_node.search(140) == nullptr);
        return passed;
    });

    tester("6. burrowing from the right", [&]{
        BPlusTree<int,int,4>::BPlusNode* even_leaf_1 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_1->emplace(tree4,0,0);
        even_leaf_1->emplace(tree4,10,10);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_2 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_2->emplace(tree4,30,30);
        even_leaf_2->emplace(tree4,20,20);
        even_leaf_2->emplace(tree4,40,40);
        even_leaf_2->emplace(tree4,50,50);
        BPlusTree<int,int,4>::BPlusNode even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];

        _ASSERT(even_node.erase(tree4,10) == true);
        _ASSERT(even_node.m_key_counter == 2);
        _ASSERT(even_leaf_1->m_key_counter == 2);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[1]) == 20);
        _ASSERT(even_leaf_2->m_key_counter == 3);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[0]) == 30);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[1]) == 40);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[2]) == 50);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(even_node.search(10) == nullptr);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        even_node.erase_all();

        BPlusTree<int,int,5>::BPlusNode* odd_leaf_1 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_1->emplace(tree5,0,0);
        odd_leaf_1->emplace(tree5,10,10);
        odd_leaf_1->emplace(tree5,-10,-10);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_2 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_2->emplace(tree5,30,30);
        odd_leaf_2->emplace(tree5,20,20);
        odd_leaf_2->emplace(tree5,40,40);
        odd_leaf_2->emplace(tree5,50,50);
        BPlusTree<int,int,5>::BPlusNode odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];

        _ASSERT(odd_node.erase(tree5,10) == true);
        _ASSERT(odd_node.m_key_counter == 2);
        _ASSERT(odd_leaf_1->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[0]) == -10);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[1]) == 0);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[2]) == 20);
        _ASSERT(odd_leaf_2->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[0]) == 30);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[1]) == 40);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[2]) == 50);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(odd_node.search(10) == nullptr);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        odd_node.erase_all();

        return passed;
    });

    tester("7. burrowing from the left", [&]{
        BPlusTree<int,int,4>::BPlusNode* even_leaf_1 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_1->emplace(tree4,0,0);
        even_leaf_1->emplace(tree4,10,10);
        even_leaf_1->emplace(tree4,30,30);
        even_leaf_1->emplace(tree4,20,20);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_2 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_2->emplace(tree4,40,40);
        even_leaf_2->emplace(tree4,50,50);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_3 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_3->emplace(tree4,60,60);
        even_leaf_3->emplace(tree4,70,70);
        even_leaf_3->emplace(tree4,80,80);
        BPlusTree<int,int,4>::BPlusNode even_node (false);
        even_node.m_key_counter = 3;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        std::get<1>(even_node.m_data)[2] = even_leaf_3;
        even_node.m_keys[2] = even_leaf_3->m_keys[0];
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];

        _ASSERT(even_node.erase(tree4,40) == true);
        _ASSERT(even_node.m_key_counter == 3);
        _ASSERT(even_leaf_1->m_key_counter == 3);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[1]) == 10);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[2]) == 20);
        _ASSERT(even_leaf_2->m_key_counter == 2);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[0]) == 30);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[1]) == 50);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(even_node.search(40) == nullptr);
        _ASSERT(*(even_node.search(50)) == 50);
        even_node.erase_all();

        BPlusTree<int,int,5>::BPlusNode* odd_leaf_1 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_1->emplace(tree5,0,0);
        odd_leaf_1->emplace(tree5,10,10);
        odd_leaf_1->emplace(tree5,-10,-10);
        odd_leaf_1->emplace(tree5,20,20);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_2 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_2->emplace(tree5,30,30);
        odd_leaf_2->emplace(tree5,40,40);
        odd_leaf_2->emplace(tree5,50,50);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_3 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_3->emplace(tree5,60,60);
        odd_leaf_3->emplace(tree5,70,70);
        odd_leaf_3->emplace(tree5,80,80);
        BPlusTree<int,int,5>::BPlusNode odd_node (false);
        odd_node.m_key_counter = 3;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        std::get<1>(odd_node.m_data)[2] = odd_leaf_3;
        odd_node.m_keys[2] = odd_leaf_3->m_keys[0];
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];

        _ASSERT(odd_node.erase(tree5,40) == true);
        _ASSERT(odd_node.m_key_counter == 3);
        _ASSERT(odd_leaf_1->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[0]) == -10);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[1]) == 0);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[2]) == 10);
        _ASSERT(odd_leaf_2->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[0]) == 20);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[1]) == 30);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[2]) == 50);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(odd_node.search(40) == nullptr);
        _ASSERT(*(odd_node.search(50)) == 50);
        odd_node.erase_all();

        return passed;
    });

    tester("8. merging with the right", [&]{
        BPlusTree<int,int,4>::BPlusNode* even_leaf_1 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_1->emplace(tree4,0,0);
        even_leaf_1->emplace(tree4,10,10);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_2 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_2->emplace(tree4,30,30);
        even_leaf_2->emplace(tree4,20,20);
        BPlusTree<int,int,4>::BPlusNode even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];

        _ASSERT(even_node.erase(tree4,10) == true);
        _ASSERT(even_node.m_key_counter == 1);
        _ASSERT(even_leaf_1->m_key_counter == 3);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[1]) == 20);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[2]) == 30);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(even_node.search(10) == nullptr);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        even_node.erase_all();

        BPlusTree<int,int,5>::BPlusNode* odd_leaf_1 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_1->emplace(tree5,0,0);
        odd_leaf_1->emplace(tree5,10,10);
        odd_leaf_1->emplace(tree5,-10,-10);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_2 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_2->emplace(tree5,30,30);
        odd_leaf_2->emplace(tree5,20,20);
        odd_leaf_2->emplace(tree5,40,40);
        BPlusTree<int,int,5>::BPlusNode odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];

        _ASSERT(odd_node.erase(tree5,10) == true);
        _ASSERT(odd_node.m_key_counter == 1);
        _ASSERT(odd_leaf_1->m_key_counter == 5);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[0]) == -10);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[1]) == 0);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[2]) == 20);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[3]) == 30);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[4]) == 40);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(odd_node.search(10) == nullptr);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        odd_node.erase_all();

        return passed;
    });

    tester("9. merging with the left", [&]{
        BPlusTree<int,int,4>::BPlusNode* even_leaf_1 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_1->emplace(tree4,0,0);
        even_leaf_1->emplace(tree4,10,10);
        even_leaf_1->emplace(tree4,30,30);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_2 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_2->emplace(tree4,40,40);
        even_leaf_2->emplace(tree4,50,50);
        BPlusTree<int,int,4>::BPlusNode* even_leaf_3 = new BPlusTree<int,int,4>::BPlusNode(true);
        even_leaf_3->emplace(tree4,60,60);
        even_leaf_3->emplace(tree4,70,70);
        even_leaf_3->emplace(tree4,80,80);
        BPlusTree<int,int,4>::BPlusNode even_node (false);
        even_node.m_key_counter = 3;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        std::get<1>(even_node.m_data)[2] = even_leaf_3;
        even_node.m_keys[2] = even_leaf_3->m_keys[0];
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];

        _ASSERT(even_node.erase(tree4,40) == true);
        _ASSERT(even_node.m_key_counter == 2);
        _ASSERT(std::get<1>(even_node.m_data)[0] == even_leaf_1);
        _ASSERT(std::get<1>(even_node.m_data)[1] == even_leaf_3);
        _ASSERT(even_leaf_1->m_key_counter == 4);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[1]) == 10);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[2]) == 30);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[3]) == 50);
        _ASSERT(even_leaf_3->m_key_counter == 3);
        _ASSERT(*(std::get<0>(even_leaf_3->m_data)[0]) == 60);
        _ASSERT(*(std::get<0>(even_leaf_3->m_data)[1]) == 70);
        _ASSERT(*(std::get<0>(even_leaf_3->m_data)[2]) == 80);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(even_node.search(40) == nullptr);
        _ASSERT(*(even_node.search(50)) == 50);
        even_node.erase_all();

        BPlusTree<int,int,5>::BPlusNode* odd_leaf_1 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_1->emplace(tree5,0,0);
        odd_leaf_1->emplace(tree5,10,10);
        odd_leaf_1->emplace(tree5,20,20);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_2 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_2->emplace(tree5,30,30);
        odd_leaf_2->emplace(tree5,40,40);
        odd_leaf_2->emplace(tree5,50,50);
        BPlusTree<int,int,5>::BPlusNode* odd_leaf_3 = new BPlusTree<int,int,5>::BPlusNode(true);
        odd_leaf_3->emplace(tree5,60,60);
        odd_leaf_3->emplace(tree5,70,70);
        odd_leaf_3->emplace(tree5,80,80);
        BPlusTree<int,int,5>::BPlusNode odd_node (false);
        odd_node.m_key_counter = 3;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        std::get<1>(odd_node.m_data)[2] = odd_leaf_3;
        odd_node.m_keys[2] = odd_leaf_3->m_keys[0];
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];

        _ASSERT(odd_node.erase(tree5,50) == true);
        _ASSERT(odd_node.m_key_counter == 2);
        _ASSERT(std::get<1>(odd_node.m_data)[0] == odd_leaf_1);
        _ASSERT(std::get<1>(odd_node.m_data)[1] == odd_leaf_3);
        _ASSERT(odd_leaf_1->m_key_counter == 5);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[1]) == 10);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[2]) == 20);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[3]) == 30);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[4]) == 40);
        _ASSERT(odd_leaf_3->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_3->m_data)[0]) == 60);
        _ASSERT(*(std::get<0>(odd_leaf_3->m_data)[1]) == 70);
        _ASSERT(*(std::get<0>(odd_leaf_3->m_data)[2]) == 80);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(odd_node.search(50) == nullptr);
        odd_node.erase_all();

        return passed;
    });
}
