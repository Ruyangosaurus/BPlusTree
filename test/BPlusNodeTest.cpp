#include "../src/BPlusNode.hpp"
#include <cassert>
#include <iostream>
#include <functional>

const char* const failed = " - FAILED\n";
const char* const passed = " - PASSED\n";

#define _ASSERT(smth) if (!(smth)) return failed
#define _CONCLUDE return passed

void tester(const char* const name, std::function<const char* const ()> func) {
    std::cout << name << func();
}

int main(){
    std::cout << "LEAF TESTS:\n";

    tester("1. empty leaf", []{
        BPlusNode<4,int,int> even_leaf (true);
        BPlusNode<5,int,int> odd_leaf (true);
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 0);
        _ASSERT(even_leaf.m_next == nullptr);
        _ASSERT(odd_leaf.m_next == nullptr);
        _ASSERT(even_leaf.m_prev == nullptr);
        _ASSERT(odd_leaf.m_prev == nullptr);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.erase(0) == false);
        _ASSERT(odd_leaf.erase(0) == false);
        even_leaf.erase_all();
        odd_leaf.erase_all();
        _CONCLUDE;
    });

    tester("2. basic insertion", []{
        BPlusNode<4,int,int> even_leaf (true);
        BPlusNode<5,int,int> odd_leaf (true);
        even_leaf.insert(0,0);
        even_leaf.insert(10,10);
        even_leaf.insert(30,30);
        even_leaf.insert(20,20);
        odd_leaf.insert(20,20);
        odd_leaf.insert(40,40);
        odd_leaf.insert(30,30);
        odd_leaf.insert(0,0);
        odd_leaf.insert(10,10);
        
        _ASSERT(even_leaf.m_key_counter == 4);
        _ASSERT(odd_leaf.m_key_counter == 5);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);
        even_leaf.insert(20,80);
        odd_leaf.insert(20,80);
        _ASSERT(even_leaf.m_key_counter == 4);
        _ASSERT(odd_leaf.m_key_counter == 5);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        even_leaf.erase_all();
        odd_leaf.erase_all();
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 0);
        _CONCLUDE;
    });

    tester("3. insertion above split", []{
        BPlusNode<4,int,int> even_leaf (true);
        BPlusNode<5,int,int> odd_leaf (true);
        even_leaf.insert(10,10);
        even_leaf.insert(20,20);
        even_leaf.insert(40,40);
        even_leaf.insert(0,0);

        BPlusNode<4, int, int>* new_even_leaf = even_leaf.insert(30,30);
        _ASSERT(even_leaf.m_next == new_even_leaf);
        _ASSERT(new_even_leaf->m_prev == &even_leaf);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(((even_leaf.search(20) != nullptr) && (*(even_leaf.search(20)) == 20)) || (*(new_even_leaf->search(20)) == 20));
        _ASSERT(*(new_even_leaf->search(30)) == 30);
        _ASSERT(*(new_even_leaf->search(40)) == 40);
        even_leaf.erase_all();
        new_even_leaf->erase_all();
        delete new_even_leaf;

        odd_leaf.insert(10,10);
        odd_leaf.insert(20,20);
        odd_leaf.insert(30,30);
        odd_leaf.insert(50,50);
        odd_leaf.insert(0,0);

        BPlusNode<5, int, int>* new_odd_leaf = odd_leaf.insert(40,40);
        _ASSERT(odd_leaf.m_next == new_odd_leaf);
        _ASSERT(new_odd_leaf->m_prev == &odd_leaf);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(new_odd_leaf->search(30)) == 30);
        _ASSERT(*(new_odd_leaf->search(40)) == 40);
        _ASSERT(*(new_odd_leaf->search(50)) == 50);
        odd_leaf.erase_all();
        new_odd_leaf->erase_all();
        delete new_odd_leaf;
        _CONCLUDE;
    });

    tester("4. insertion below split", []{
        BPlusNode<4,int,int> even_leaf (true);
        BPlusNode<5,int,int> odd_leaf (true);
        even_leaf.insert(30,30);
        even_leaf.insert(20,20);
        even_leaf.insert(40,40);
        even_leaf.insert(0,0);

        BPlusNode<4, int, int>* new_even_leaf = even_leaf.insert(10,10);
        _ASSERT(even_leaf.m_next == new_even_leaf);
        _ASSERT(new_even_leaf->m_prev == &even_leaf);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(((even_leaf.search(20) != nullptr) && (*(even_leaf.search(20)) == 20)) || (*(new_even_leaf->search(20)) == 20));
        _ASSERT(*(new_even_leaf->search(30)) == 30);
        _ASSERT(*(new_even_leaf->search(40)) == 40);
        even_leaf.erase_all();
        new_even_leaf->erase_all();
        delete new_even_leaf;

        odd_leaf.insert(40,40);
        odd_leaf.insert(20,20);
        odd_leaf.insert(30,30);
        odd_leaf.insert(50,50);
        odd_leaf.insert(0,0);

        BPlusNode<5, int, int>* new_odd_leaf = odd_leaf.insert(10,10);
        _ASSERT(odd_leaf.m_next == new_odd_leaf);
        _ASSERT(new_odd_leaf->m_prev == &odd_leaf);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(new_odd_leaf->search(30)) == 30);
        _ASSERT(*(new_odd_leaf->search(40)) == 40);
        _ASSERT(*(new_odd_leaf->search(50)) == 50);
        odd_leaf.erase_all();
        new_odd_leaf->erase_all();
        delete new_odd_leaf;
        _CONCLUDE;
    });

    tester("5. insertion near split", []{
        BPlusNode<4,int,int> even_leaf (true);
        BPlusNode<5,int,int> odd_leaf (true);
        even_leaf.insert(30,30);
        even_leaf.insert(10,10);
        even_leaf.insert(40,40);
        even_leaf.insert(0,0);

        BPlusNode<4, int, int>* new_even_leaf = even_leaf.insert(20,20);
        _ASSERT(even_leaf.m_next == new_even_leaf);
        _ASSERT(new_even_leaf->m_prev == &even_leaf);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(((even_leaf.search(20) != nullptr) && (*(even_leaf.search(20)) == 20)) || (*(new_even_leaf->search(20)) == 20));
        _ASSERT(*(new_even_leaf->search(30)) == 30);
        _ASSERT(*(new_even_leaf->search(40)) == 40);
        even_leaf.erase_all();
        new_even_leaf->erase_all();
        delete new_even_leaf;

        odd_leaf.insert(40,40);
        odd_leaf.insert(10,10);
        odd_leaf.insert(30,30);
        odd_leaf.insert(50,50);
        odd_leaf.insert(0,0);

        BPlusNode<5, int, int>* new_odd_leaf = odd_leaf.insert(20,20);
        _ASSERT(odd_leaf.m_next == new_odd_leaf);
        _ASSERT(new_odd_leaf->m_prev == &odd_leaf);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(new_odd_leaf->search(30)) == 30);
        _ASSERT(*(new_odd_leaf->search(40)) == 40);
        _ASSERT(*(new_odd_leaf->search(50)) == 50);
        odd_leaf.erase_all();
        new_odd_leaf->erase_all();
        delete new_odd_leaf;

        odd_leaf.insert(40,40);
        odd_leaf.insert(10,10);
        odd_leaf.insert(20,20);
        odd_leaf.insert(50,50);
        odd_leaf.insert(0,0);

        new_odd_leaf = odd_leaf.insert(30,30);
        _ASSERT(odd_leaf.m_next == new_odd_leaf);
        _ASSERT(new_odd_leaf->m_prev == &odd_leaf);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(new_odd_leaf->search(30)) == 30);
        _ASSERT(*(new_odd_leaf->search(40)) == 40);
        _ASSERT(*(new_odd_leaf->search(50)) == 50);
        odd_leaf.erase_all();
        new_odd_leaf->erase_all();
        delete new_odd_leaf;
        _CONCLUDE;
    });

    tester("6. duplicate insertion", []{
        BPlusNode<4,int,int> even_leaf (true);
        BPlusNode<5,int,int> odd_leaf (true);
        even_leaf.insert(0,0);
        odd_leaf.insert(10,10);
        
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);

        even_leaf.insert(0,20);
        odd_leaf.insert(10,30);
        _ASSERT(even_leaf.m_key_counter == 1);
        _ASSERT(odd_leaf.m_key_counter == 1);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(10)) == 10);

        even_leaf.erase_all();
        odd_leaf.erase_all();
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 0);
        _CONCLUDE;
    });

    tester("7. deletion", []{
        BPlusNode<4,int,int> even_leaf (true);
        BPlusNode<5,int,int> odd_leaf (true);
        even_leaf.insert(0,0);
        even_leaf.insert(10,10);
        even_leaf.insert(30,30);
        even_leaf.insert(20,20);
        odd_leaf.insert(20,20);
        odd_leaf.insert(40,40);
        odd_leaf.insert(30,30);
        odd_leaf.insert(0,0);
        odd_leaf.insert(10,10);
        
        _ASSERT(even_leaf.m_key_counter == 4);
        _ASSERT(odd_leaf.m_key_counter == 5);
        _ASSERT(*(even_leaf.search(0)) == 0);
        _ASSERT(*(odd_leaf.search(0)) == 0);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase(0);
        odd_leaf.erase(0);
        _ASSERT(even_leaf.m_key_counter == 3);
        _ASSERT(odd_leaf.m_key_counter == 4);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(*(even_leaf.search(10)) == 10);
        _ASSERT(*(odd_leaf.search(10)) == 10);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase(10);
        odd_leaf.erase(10);
        _ASSERT(even_leaf.m_key_counter == 2);
        _ASSERT(odd_leaf.m_key_counter == 3);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        _ASSERT(even_leaf.erase(10) == false); // already erased from the subtree
        _ASSERT(odd_leaf.erase(10) == false);
        _ASSERT(even_leaf.m_key_counter == 2);
        _ASSERT(odd_leaf.m_key_counter == 3);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        _ASSERT(even_leaf.erase(90) == false); // never was in the subtree
        _ASSERT(odd_leaf.erase(90) == false);
        _ASSERT(even_leaf.m_key_counter == 2);
        _ASSERT(odd_leaf.m_key_counter == 3);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(*(even_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(30)) == 30);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase(30);
        odd_leaf.erase(30);
        _ASSERT(even_leaf.m_key_counter == 1);
        _ASSERT(odd_leaf.m_key_counter == 2);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(*(even_leaf.search(20)) == 20);
        _ASSERT(*(odd_leaf.search(20)) == 20);
        _ASSERT(even_leaf.search(30) == nullptr);
        _ASSERT(odd_leaf.search(30) == nullptr);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase(20);
        odd_leaf.erase(20);
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 1);
        _ASSERT(even_leaf.search(0) == nullptr);
        _ASSERT(odd_leaf.search(0) == nullptr);
        _ASSERT(even_leaf.search(10) == nullptr);
        _ASSERT(odd_leaf.search(10) == nullptr);
        _ASSERT(even_leaf.search(20) == nullptr);
        _ASSERT(odd_leaf.search(20) == nullptr);
        _ASSERT(even_leaf.search(30) == nullptr);
        _ASSERT(odd_leaf.search(30) == nullptr);
        _ASSERT(*(odd_leaf.search(40)) == 40);

        even_leaf.erase_all();
        odd_leaf.erase_all();
        _ASSERT(even_leaf.m_key_counter == 0);
        _ASSERT(odd_leaf.m_key_counter == 0);
        _CONCLUDE;
    });

    std::cout << "INTERNAL NODE TESTS:\n";
    
    tester("8. search", []{
        BPlusNode<4,int,int> even_leaf_1 (true);
        even_leaf_1.insert(0,0);
        even_leaf_1.insert(10,10);
        even_leaf_1.insert(30,30);
        even_leaf_1.insert(20,20);
        BPlusNode<4,int,int> even_leaf_2 (true);
        even_leaf_2.insert(40,40);
        even_leaf_2.insert(50,50);
        even_leaf_2.insert(60,60);
        even_leaf_2.insert(70,70);
        BPlusNode<4,int,int> even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = &even_leaf_1;
        std::get<1>(even_node.m_data)[1] = &even_leaf_2;
        even_node.m_keys[0] = even_leaf_1.m_keys[0];
        even_node.m_keys[1] = even_leaf_2.m_keys[0];

        _ASSERT(even_node.m_key_counter == 2);
        _ASSERT(even_node.m_keys[0] == 0);
        _ASSERT(even_node.m_keys[1] == 40);
        _ASSERT(std::get<1>(even_node.m_data)[0] == &even_leaf_1);
        _ASSERT(std::get<1>(even_node.m_data)[1] == &even_leaf_2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(*(even_node.search(70)) == 70);
        _ASSERT(even_node.search(-1) == nullptr);
        even_leaf_1.erase_all();
        even_leaf_2.erase_all();

        BPlusNode<5,int,int> odd_leaf_1 (true);
        odd_leaf_1.insert(0,0);
        odd_leaf_1.insert(10,10);
        odd_leaf_1.insert(30,30);
        odd_leaf_1.insert(-10,-10);
        odd_leaf_1.insert(20,20);
        BPlusNode<5,int,int> odd_leaf_2 (true);
        odd_leaf_2.insert(40,40);
        odd_leaf_2.insert(50,50);
        odd_leaf_2.insert(60,60);
        odd_leaf_2.insert(80,80);
        odd_leaf_2.insert(70,70);
        BPlusNode<5,int,int> odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = &odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = &odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1.m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2.m_keys[0];

        _ASSERT(odd_node.m_key_counter == 2);
        _ASSERT(odd_node.m_keys[0] == -10);
        _ASSERT(odd_node.m_keys[1] == 40);
        _ASSERT(std::get<1>(odd_node.m_data)[0] == &odd_leaf_1);
        _ASSERT(std::get<1>(odd_node.m_data)[1] == &odd_leaf_2);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(odd_node.search(-1) == nullptr);
        odd_leaf_1.erase_all();
        odd_leaf_2.erase_all();
        _CONCLUDE;
    });

    tester("9. basic insertion", []{
        BPlusNode<4,int,int> even_leaf_1 (true);
        even_leaf_1.insert(0,0);
        even_leaf_1.insert(10,10);
        BPlusNode<4,int,int> even_leaf_2 (true);
        even_leaf_2.insert(60,60);
        even_leaf_2.insert(70,70);
        BPlusNode<4,int,int> even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = &even_leaf_1;
        std::get<1>(even_node.m_data)[1] = &even_leaf_2;
        even_node.m_keys[0] = even_leaf_1.m_keys[0];
        even_node.m_keys[1] = 40;

        even_node.insert(30,30);
        even_node.insert(20,20);
        even_node.insert(40,40);
        even_node.insert(50,50);

        _ASSERT(even_node.m_key_counter == 2);
        _ASSERT(even_node.m_keys[0] == 0);
        _ASSERT(even_node.m_keys[1] == 40);
        _ASSERT(std::get<1>(even_node.m_data)[0] == &even_leaf_1);
        _ASSERT(std::get<1>(even_node.m_data)[1] == &even_leaf_2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(*(even_node.search(70)) == 70);
        even_leaf_1.erase_all();
        even_leaf_2.erase_all();

        BPlusNode<5,int,int> odd_leaf_1 (true);
        odd_leaf_1.insert(0,0);
        odd_leaf_1.insert(10,10);
        odd_leaf_1.insert(30,30);
        BPlusNode<5,int,int> odd_leaf_2 (true);
        odd_leaf_2.insert(40,40);
        odd_leaf_2.insert(50,50);
        
        BPlusNode<5,int,int> odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = &odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = &odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1.m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2.m_keys[0];

        odd_node.insert(-10,-10);
        odd_node.insert(20,20);
        odd_node.insert(60,60);
        odd_node.insert(80,80);
        odd_node.insert(70,70);

        _ASSERT(odd_node.m_key_counter == 2);
        _ASSERT(odd_node.m_keys[0] == -10);
        _ASSERT(odd_node.m_keys[1] == 40);
        _ASSERT(std::get<1>(odd_node.m_data)[0] == &odd_leaf_1);
        _ASSERT(std::get<1>(odd_node.m_data)[1] == &odd_leaf_2);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        odd_leaf_1.erase_all();
        odd_leaf_2.erase_all();
        _CONCLUDE;
    });

    tester("10. insertion with subnode splitting", []{
        BPlusNode<4,int,int> even_leaf_1 (true);
        even_leaf_1.insert(0,0);
        even_leaf_1.insert(10,10);
        even_leaf_1.insert(30,30);
        even_leaf_1.insert(20,20);
        BPlusNode<4,int,int> even_leaf_2 (true);
        even_leaf_2.insert(80,80);
        even_leaf_2.insert(50,50);
        even_leaf_2.insert(60,60);
        even_leaf_2.insert(70,70);
        BPlusNode<4,int,int> even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = &even_leaf_1;
        std::get<1>(even_node.m_data)[1] = &even_leaf_2;
        even_node.m_keys[0] = even_leaf_1.m_keys[0];
        even_node.m_keys[1] = even_leaf_2.m_keys[0];
        even_node.insert(40,40);

        _ASSERT(even_node.m_key_counter == 3);
        _ASSERT(even_node.m_keys[0] == 0);
        _ASSERT(even_node.m_keys[2] == 50);
        _ASSERT(std::get<1>(even_node.m_data)[0] == &even_leaf_1);
        _ASSERT(std::get<1>(even_node.m_data)[2] == &even_leaf_2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(*(even_node.search(70)) == 70);
        _ASSERT(*(even_node.search(80)) == 80);
        even_leaf_1.erase_all();
        even_leaf_2.erase_all();
        std::get<1>(even_node.m_data)[1]->erase_all();
        delete std::get<1>(even_node.m_data)[1];

        BPlusNode<5,int,int> odd_leaf_1 (true);
        odd_leaf_1.insert(0,0);
        odd_leaf_1.insert(10,10);
        odd_leaf_1.insert(30,30);
        odd_leaf_1.insert(-10,-10);
        odd_leaf_1.insert(20,20);
        BPlusNode<5,int,int> odd_leaf_2 (true);
        odd_leaf_2.insert(40,40);
        odd_leaf_2.insert(50,50);
        odd_leaf_2.insert(60,60);
        odd_leaf_2.insert(80,80);
        odd_leaf_2.insert(70,70);
        BPlusNode<5,int,int> odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = &odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = &odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1.m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2.m_keys[0];

        odd_node.insert(-20,-20);
        _ASSERT(odd_node.m_key_counter == 3);
        _ASSERT(odd_node.m_keys[0] == -20);
        _ASSERT(odd_node.m_keys[2] == 40);
        _ASSERT(std::get<1>(odd_node.m_data)[0] == &odd_leaf_1);
        _ASSERT(std::get<1>(odd_node.m_data)[2] == &odd_leaf_2);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(odd_node.search(-1) == nullptr);
        odd_leaf_1.erase_all();
        odd_leaf_2.erase_all();
        std::get<1>(odd_node.m_data)[1]->erase_all();
        delete std::get<1>(odd_node.m_data)[1];
        _CONCLUDE;
    });

    tester("11. insertion with this splitting", []{
        BPlusNode<4,int,int>* even_leaf_1 = new BPlusNode<4,int,int>(true);
        even_leaf_1->insert(0,0);
        even_leaf_1->insert(10,10);
        BPlusNode<4,int,int>* even_leaf_2 = new BPlusNode<4,int,int>(true);
        even_leaf_2->insert(30,30);
        even_leaf_2->insert(20,20);
        even_leaf_2->insert(40,40);
        BPlusNode<4,int,int>* even_leaf_3 = new BPlusNode<4,int,int>(true);
        even_leaf_3->insert(50,50);
        even_leaf_3->insert(60,60);
        even_leaf_3->insert(70,70);
        even_leaf_3->insert(80,80);
        BPlusNode<4,int,int>* even_leaf_4 = new BPlusNode<4,int,int>(true);
        even_leaf_4->insert(120,120);
        even_leaf_4->insert(100,100);
        even_leaf_4->insert(110,110);
        BPlusNode<4,int,int> even_node (false);
        even_node.m_key_counter = 4;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        std::get<1>(even_node.m_data)[2] = even_leaf_3;
        std::get<1>(even_node.m_data)[3] = even_leaf_4;
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];
        even_node.m_keys[2] = even_leaf_3->m_keys[0];
        even_node.m_keys[3] = even_leaf_4->m_keys[0];
        auto new_even_node = even_node.insert(90,90);

        _ASSERT(1 < even_node.m_key_counter && even_node.m_key_counter < 4);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(((even_node.search(50) != nullptr) && (*(even_node.search(50)) == 50)) || (*(new_even_node->search(50)) == 50));
        _ASSERT(((even_node.search(60) != nullptr) && (*(even_node.search(60)) == 60)) || (*(new_even_node->search(60)) == 60));
        _ASSERT(((even_node.search(70) != nullptr) && (*(even_node.search(70)) == 70)) || (*(new_even_node->search(70)) == 70));
        _ASSERT(*(new_even_node->search(80)) == 80);
        _ASSERT(*(new_even_node->search(90)) == 90);
        _ASSERT(*(new_even_node->search(100)) == 100);
        _ASSERT(*(new_even_node->search(110)) == 110);
        _ASSERT(*(new_even_node->search(120)) == 120);
        even_node.erase_all();
        new_even_node->erase_all();
        delete new_even_node;

        BPlusNode<5,int,int>* odd_leaf_1 = new BPlusNode<5,int,int>(true);
        odd_leaf_1->insert(-20,-20);
        odd_leaf_1->insert(0,0);
        odd_leaf_1->insert(-10,-10);
        BPlusNode<5,int,int>* odd_leaf_2 = new BPlusNode<5,int,int>(true);
        odd_leaf_2->insert(30,30);
        odd_leaf_2->insert(20,20);
        odd_leaf_2->insert(10,10);
        BPlusNode<5,int,int>* odd_leaf_3 = new BPlusNode<5,int,int>(true);
        odd_leaf_3->insert(50,50);
        odd_leaf_3->insert(40,40);
        odd_leaf_3->insert(60,60);
        odd_leaf_3->insert(70,70);
        odd_leaf_3->insert(80,80);
        BPlusNode<5,int,int>* odd_leaf_4 = new BPlusNode<5,int,int>(true);
        odd_leaf_4->insert(120,120);
        odd_leaf_4->insert(100,100);
        odd_leaf_4->insert(110,110);
        BPlusNode<5,int,int>* odd_leaf_5 = new BPlusNode<5,int,int>(true);
        odd_leaf_5->insert(130,130);
        odd_leaf_5->insert(140,140);
        odd_leaf_5->insert(150,150);
        BPlusNode<5,int,int> odd_node (false);
        odd_node.m_key_counter = 5;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        std::get<1>(odd_node.m_data)[2] = odd_leaf_3;
        std::get<1>(odd_node.m_data)[3] = odd_leaf_4;
        std::get<1>(odd_node.m_data)[4] = odd_leaf_5;
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];
        odd_node.m_keys[2] = odd_leaf_3->m_keys[0];
        odd_node.m_keys[3] = odd_leaf_4->m_keys[0];
        odd_node.m_keys[4] = odd_leaf_5->m_keys[0];
        auto new_odd_node = odd_node.insert(90,90);

        _ASSERT(1 < odd_node.m_key_counter && odd_node.m_key_counter < 4);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(new_odd_node->search(70)) == 70);
        _ASSERT(*(new_odd_node->search(80)) == 80);
        _ASSERT(*(new_odd_node->search(90)) == 90);
        _ASSERT(*(new_odd_node->search(100)) == 100);
        _ASSERT(*(new_odd_node->search(110)) == 110);
        _ASSERT(*(new_odd_node->search(120)) == 120);
        _ASSERT(*(new_odd_node->search(130)) == 130);
        _ASSERT(*(new_odd_node->search(140)) == 140);
        _ASSERT(*(new_odd_node->search(150)) == 150);
        odd_node.erase_all();
        new_odd_node->erase_all();
        delete new_odd_node;
        _CONCLUDE;
    });

    tester("12. basic deletion", []{
        BPlusNode<4,int,int>* even_leaf_1 = new BPlusNode<4,int,int>(true);
        even_leaf_1->insert(0,0);
        even_leaf_1->insert(10,10);
        BPlusNode<4,int,int>* even_leaf_2 = new BPlusNode<4,int,int>(true);
        even_leaf_2->insert(30,30);
        even_leaf_2->insert(20,20);
        even_leaf_2->insert(40,40);
        BPlusNode<4,int,int>* even_leaf_3 = new BPlusNode<4,int,int>(true);
        even_leaf_3->insert(50,50);
        even_leaf_3->insert(60,60);
        even_leaf_3->insert(70,70);
        even_leaf_3->insert(80,80);
        BPlusNode<4,int,int>* even_leaf_4 = new BPlusNode<4,int,int>(true);
        even_leaf_4->insert(120,120);
        even_leaf_4->insert(100,100);
        even_leaf_4->insert(110,110);
        BPlusNode<4,int,int> even_node (false);
        even_node.m_key_counter = 4;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        std::get<1>(even_node.m_data)[2] = even_leaf_3;
        std::get<1>(even_node.m_data)[3] = even_leaf_4;
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];
        even_node.m_keys[2] = even_leaf_3->m_keys[0];
        even_node.m_keys[3] = even_leaf_4->m_keys[0];

        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(*(even_node.search(70)) == 70);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(*(even_node.search(100)) == 100);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);

        _ASSERT(even_node.erase(70) == true);
        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(std::get<1>(even_node.m_data)[2]->m_key_counter == 3);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(*(even_node.search(100)) == 100);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);

        _ASSERT(even_node.erase(100) == true);
        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(std::get<1>(even_node.m_data)[3]->m_key_counter == 2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(even_node.search(100) == nullptr);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);

        _ASSERT(even_node.erase(100) == false); // already erased from the subtree
        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(std::get<1>(even_node.m_data)[3]->m_key_counter == 2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(even_node.search(100) == nullptr);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);

        _ASSERT(even_node.erase(200) == false); // never was in the subtree
        _ASSERT(even_node.m_key_counter == 4);
        _ASSERT(std::get<1>(even_node.m_data)[3]->m_key_counter == 2);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        _ASSERT(*(even_node.search(60)) == 60);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(*(even_node.search(80)) == 80);
        _ASSERT(even_node.search(100) == nullptr);
        _ASSERT(*(even_node.search(110)) == 110);
        _ASSERT(*(even_node.search(120)) == 120);
        even_node.erase_all();

        _ASSERT(even_node.m_key_counter == 0);
        _ASSERT(even_node.search(-20) == nullptr);
        _ASSERT(even_node.search(-10) == nullptr);
        _ASSERT(even_node.search(0) == nullptr);
        _ASSERT(even_node.search(10) == nullptr);
        _ASSERT(even_node.search(20) == nullptr);
        _ASSERT(even_node.search(30) == nullptr);
        _ASSERT(even_node.search(40) == nullptr);
        _ASSERT(even_node.search(50) == nullptr);
        _ASSERT(even_node.search(60) == nullptr);
        _ASSERT(even_node.search(70) == nullptr);
        _ASSERT(even_node.search(80) == nullptr);
        _ASSERT(even_node.search(90) == nullptr);
        _ASSERT(even_node.search(100) == nullptr);
        _ASSERT(even_node.search(110) == nullptr);
        _ASSERT(even_node.search(120) == nullptr);
        _ASSERT(even_node.search(130) == nullptr);
        _ASSERT(even_node.search(140) == nullptr);

        BPlusNode<5,int,int>* odd_leaf_1 = new BPlusNode<5,int,int>(true);
        odd_leaf_1->insert(-20,-20);
        odd_leaf_1->insert(0,0);
        odd_leaf_1->insert(-10,-10);
        BPlusNode<5,int,int>* odd_leaf_2 = new BPlusNode<5,int,int>(true);
        odd_leaf_2->insert(30,30);
        odd_leaf_2->insert(20,20);
        odd_leaf_2->insert(10,10);
        BPlusNode<5,int,int>* odd_leaf_3 = new BPlusNode<5,int,int>(true);
        odd_leaf_3->insert(50,50);
        odd_leaf_3->insert(40,40);
        odd_leaf_3->insert(60,60);
        odd_leaf_3->insert(70,70);
        odd_leaf_3->insert(80,80);
        BPlusNode<5,int,int>* odd_leaf_4 = new BPlusNode<5,int,int>(true);
        odd_leaf_4->insert(120,120);
        odd_leaf_4->insert(100,100);
        odd_leaf_4->insert(110,110);
        BPlusNode<5,int,int>* odd_leaf_5 = new BPlusNode<5,int,int>(true);
        odd_leaf_5->insert(130,130);
        odd_leaf_5->insert(140,140);
        odd_leaf_5->insert(150,150);
        BPlusNode<5,int,int> odd_node (false);
        odd_node.m_key_counter = 5;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        std::get<1>(odd_node.m_data)[2] = odd_leaf_3;
        std::get<1>(odd_node.m_data)[3] = odd_leaf_4;
        std::get<1>(odd_node.m_data)[4] = odd_leaf_5;
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];
        odd_node.m_keys[2] = odd_leaf_3->m_keys[0];
        odd_node.m_keys[3] = odd_leaf_4->m_keys[0];
        odd_node.m_keys[4] = odd_leaf_5->m_keys[0];

        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(*(odd_node.search(60)) == 60);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);

        _ASSERT(odd_node.erase(60) == true);
        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(*(odd_node.search(70)) == 70);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);

        _ASSERT(odd_node.erase(70) == true);
        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(odd_node.search(70) == nullptr);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);

        _ASSERT(odd_node.erase(70) == false);
        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(odd_node.search(70) == nullptr);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);

        _ASSERT(odd_node.erase(470) == false);
        _ASSERT(odd_node.m_key_counter == 5);
        _ASSERT(*(odd_node.search(-20)) == -20);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(odd_node.search(70) == nullptr);
        _ASSERT(*(odd_node.search(80)) == 80);
        _ASSERT(*(odd_node.search(100)) == 100);
        _ASSERT(*(odd_node.search(110)) == 110);
        _ASSERT(*(odd_node.search(120)) == 120);
        _ASSERT(*(odd_node.search(130)) == 130);
        _ASSERT(*(odd_node.search(140)) == 140);
        _ASSERT(*(odd_node.search(150)) == 150);
        odd_node.erase_all();

        _ASSERT(odd_node.m_key_counter == 0);
        _ASSERT(odd_node.search(-20) == nullptr);
        _ASSERT(odd_node.search(-10) == nullptr);
        _ASSERT(odd_node.search(0) == nullptr);
        _ASSERT(odd_node.search(10) == nullptr);
        _ASSERT(odd_node.search(20) == nullptr);
        _ASSERT(odd_node.search(30) == nullptr);
        _ASSERT(odd_node.search(40) == nullptr);
        _ASSERT(odd_node.search(50) == nullptr);
        _ASSERT(odd_node.search(60) == nullptr);
        _ASSERT(odd_node.search(70) == nullptr);
        _ASSERT(odd_node.search(80) == nullptr);
        _ASSERT(odd_node.search(90) == nullptr);
        _ASSERT(odd_node.search(100) == nullptr);
        _ASSERT(odd_node.search(110) == nullptr);
        _ASSERT(odd_node.search(120) == nullptr);
        _ASSERT(odd_node.search(130) == nullptr);
        _ASSERT(odd_node.search(140) == nullptr);
        _CONCLUDE;
    });

    tester("13. burrowing from the right", []{
        BPlusNode<4,int,int>* even_leaf_1 = new BPlusNode<4,int,int>(true);
        even_leaf_1->insert(0,0);
        even_leaf_1->insert(10,10);
        BPlusNode<4,int,int>* even_leaf_2 = new BPlusNode<4,int,int>(true);
        even_leaf_2->insert(30,30);
        even_leaf_2->insert(20,20);
        even_leaf_2->insert(40,40);
        even_leaf_2->insert(50,50);
        BPlusNode<4,int,int> even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];

        _ASSERT(even_node.erase(10) == true);
        _ASSERT(even_node.m_key_counter == 2);
        _ASSERT(even_leaf_1->m_key_counter == 2);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[1]) == 20);
        _ASSERT(even_leaf_2->m_key_counter == 3);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[0]) == 30);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[1]) == 40);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[2]) == 50);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(even_node.search(10) == nullptr);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(*(even_node.search(40)) == 40);
        _ASSERT(*(even_node.search(50)) == 50);
        even_node.erase_all();

        BPlusNode<5,int,int>* odd_leaf_1 = new BPlusNode<5,int,int>(true);
        odd_leaf_1->insert(0,0);
        odd_leaf_1->insert(10,10);
        odd_leaf_1->insert(-10,-10);
        BPlusNode<5,int,int>* odd_leaf_2 = new BPlusNode<5,int,int>(true);
        odd_leaf_2->insert(30,30);
        odd_leaf_2->insert(20,20);
        odd_leaf_2->insert(40,40);
        odd_leaf_2->insert(50,50);
        BPlusNode<5,int,int> odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];

        _ASSERT(odd_node.erase(10) == true);
        _ASSERT(odd_node.m_key_counter == 2);
        _ASSERT(odd_leaf_1->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[0]) == -10);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[1]) == 0);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[2]) == 20);
        _ASSERT(odd_leaf_2->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[0]) == 30);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[1]) == 40);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[2]) == 50);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(odd_node.search(10) == nullptr);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(*(odd_node.search(50)) == 50);
        odd_node.erase_all();

        _CONCLUDE;
    });

    tester("14. burrowing from the left", []{
        BPlusNode<4,int,int>* even_leaf_1 = new BPlusNode<4,int,int>(true);
        even_leaf_1->insert(0,0);
        even_leaf_1->insert(10,10);
        even_leaf_1->insert(30,30);
        even_leaf_1->insert(20,20);
        BPlusNode<4,int,int>* even_leaf_2 = new BPlusNode<4,int,int>(true);
        even_leaf_2->insert(40,40);
        even_leaf_2->insert(50,50);
        BPlusNode<4,int,int>* even_leaf_3 = new BPlusNode<4,int,int>(true);
        even_leaf_3->insert(60,60);
        even_leaf_3->insert(70,70);
        even_leaf_3->insert(80,80);
        BPlusNode<4,int,int> even_node (false);
        even_node.m_key_counter = 3;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        std::get<1>(even_node.m_data)[2] = even_leaf_3;
        even_node.m_keys[2] = even_leaf_3->m_keys[0];
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];

        _ASSERT(even_node.erase(40) == true);
        _ASSERT(even_node.m_key_counter == 3);
        _ASSERT(even_leaf_1->m_key_counter == 3);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[1]) == 10);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[2]) == 20);
        _ASSERT(even_leaf_2->m_key_counter == 2);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[0]) == 30);
        _ASSERT(*(std::get<0>(even_leaf_2->m_data)[1]) == 50);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(even_node.search(40) == nullptr);
        _ASSERT(*(even_node.search(50)) == 50);
        even_node.erase_all();

        BPlusNode<5,int,int>* odd_leaf_1 = new BPlusNode<5,int,int>(true);
        odd_leaf_1->insert(0,0);
        odd_leaf_1->insert(10,10);
        odd_leaf_1->insert(-10,-10);
        odd_leaf_1->insert(20,20);
        BPlusNode<5,int,int>* odd_leaf_2 = new BPlusNode<5,int,int>(true);
        odd_leaf_2->insert(30,30);
        odd_leaf_2->insert(40,40);
        odd_leaf_2->insert(50,50);
        BPlusNode<5,int,int>* odd_leaf_3 = new BPlusNode<5,int,int>(true);
        odd_leaf_3->insert(60,60);
        odd_leaf_3->insert(70,70);
        odd_leaf_3->insert(80,80);
        BPlusNode<5,int,int> odd_node (false);
        odd_node.m_key_counter = 3;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        std::get<1>(odd_node.m_data)[2] = odd_leaf_3;
        odd_node.m_keys[2] = odd_leaf_3->m_keys[0];
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];

        _ASSERT(odd_node.erase(40) == true);
        _ASSERT(odd_node.m_key_counter == 3);
        _ASSERT(odd_leaf_1->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[0]) == -10);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[1]) == 0);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[2]) == 10);
        _ASSERT(odd_leaf_2->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[0]) == 20);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[1]) == 30);
        _ASSERT(*(std::get<0>(odd_leaf_2->m_data)[2]) == 50);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(odd_node.search(40) == nullptr);
        _ASSERT(*(odd_node.search(50)) == 50);
        odd_node.erase_all();

        _CONCLUDE;
    });

    tester("15. merging with the right", []{
        BPlusNode<4,int,int>* even_leaf_1 = new BPlusNode<4,int,int>(true);
        even_leaf_1->insert(0,0);
        even_leaf_1->insert(10,10);
        BPlusNode<4,int,int>* even_leaf_2 = new BPlusNode<4,int,int>(true);
        even_leaf_2->insert(30,30);
        even_leaf_2->insert(20,20);
        BPlusNode<4,int,int> even_node (false);
        even_node.m_key_counter = 2;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];

        _ASSERT(even_node.erase(10) == true);
        _ASSERT(even_node.m_key_counter == 1);
        _ASSERT(even_leaf_1->m_key_counter == 3);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[1]) == 20);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[2]) == 30);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(even_node.search(10) == nullptr);
        _ASSERT(*(even_node.search(20)) == 20);
        _ASSERT(*(even_node.search(30)) == 30);
        even_node.erase_all();

        BPlusNode<5,int,int>* odd_leaf_1 = new BPlusNode<5,int,int>(true);
        odd_leaf_1->insert(0,0);
        odd_leaf_1->insert(10,10);
        odd_leaf_1->insert(-10,-10);
        BPlusNode<5,int,int>* odd_leaf_2 = new BPlusNode<5,int,int>(true);
        odd_leaf_2->insert(30,30);
        odd_leaf_2->insert(20,20);
        odd_leaf_2->insert(40,40);
        BPlusNode<5,int,int> odd_node (false);
        odd_node.m_key_counter = 2;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];

        _ASSERT(odd_node.erase(10) == true);
        _ASSERT(odd_node.m_key_counter == 1);
        _ASSERT(odd_leaf_1->m_key_counter == 5);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[0]) == -10);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[1]) == 0);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[2]) == 20);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[3]) == 30);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[4]) == 40);
        _ASSERT(*(odd_node.search(-10)) == -10);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(odd_node.search(10) == nullptr);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        odd_node.erase_all();

        _CONCLUDE;
    });

    tester("16. merging with the left", []{
        BPlusNode<4,int,int>* even_leaf_1 = new BPlusNode<4,int,int>(true);
        even_leaf_1->insert(0,0);
        even_leaf_1->insert(10,10);
        even_leaf_1->insert(30,30);
        BPlusNode<4,int,int>* even_leaf_2 = new BPlusNode<4,int,int>(true);
        even_leaf_2->insert(40,40);
        even_leaf_2->insert(50,50);
        BPlusNode<4,int,int>* even_leaf_3 = new BPlusNode<4,int,int>(true);
        even_leaf_3->insert(60,60);
        even_leaf_3->insert(70,70);
        even_leaf_3->insert(80,80);
        BPlusNode<4,int,int> even_node (false);
        even_node.m_key_counter = 3;
        std::get<1>(even_node.m_data)[0] = even_leaf_1;
        std::get<1>(even_node.m_data)[1] = even_leaf_2;
        std::get<1>(even_node.m_data)[2] = even_leaf_3;
        even_node.m_keys[2] = even_leaf_3->m_keys[0];
        even_node.m_keys[0] = even_leaf_1->m_keys[0];
        even_node.m_keys[1] = even_leaf_2->m_keys[0];

        _ASSERT(even_node.erase(40) == true);
        _ASSERT(even_node.m_key_counter == 2);
        _ASSERT(std::get<1>(even_node.m_data)[0] == even_leaf_1);
        _ASSERT(std::get<1>(even_node.m_data)[1] == even_leaf_3);
        _ASSERT(even_leaf_1->m_key_counter == 4);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[1]) == 10);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[2]) == 30);
        _ASSERT(*(std::get<0>(even_leaf_1->m_data)[3]) == 50);
        _ASSERT(even_leaf_3->m_key_counter == 3);
        _ASSERT(*(std::get<0>(even_leaf_3->m_data)[0]) == 60);
        _ASSERT(*(std::get<0>(even_leaf_3->m_data)[1]) == 70);
        _ASSERT(*(std::get<0>(even_leaf_3->m_data)[2]) == 80);
        _ASSERT(*(even_node.search(0)) == 0);
        _ASSERT(*(even_node.search(10)) == 10);
        _ASSERT(*(even_node.search(30)) == 30);
        _ASSERT(even_node.search(40) == nullptr);
        _ASSERT(*(even_node.search(50)) == 50);
        even_node.erase_all();

        BPlusNode<5,int,int>* odd_leaf_1 = new BPlusNode<5,int,int>(true);
        odd_leaf_1->insert(0,0);
        odd_leaf_1->insert(10,10);
        odd_leaf_1->insert(20,20);
        BPlusNode<5,int,int>* odd_leaf_2 = new BPlusNode<5,int,int>(true);
        odd_leaf_2->insert(30,30);
        odd_leaf_2->insert(40,40);
        odd_leaf_2->insert(50,50);
        BPlusNode<5,int,int>* odd_leaf_3 = new BPlusNode<5,int,int>(true);
        odd_leaf_3->insert(60,60);
        odd_leaf_3->insert(70,70);
        odd_leaf_3->insert(80,80);
        BPlusNode<5,int,int> odd_node (false);
        odd_node.m_key_counter = 3;
        std::get<1>(odd_node.m_data)[0] = odd_leaf_1;
        std::get<1>(odd_node.m_data)[1] = odd_leaf_2;
        std::get<1>(odd_node.m_data)[2] = odd_leaf_3;
        odd_node.m_keys[2] = odd_leaf_3->m_keys[0];
        odd_node.m_keys[0] = odd_leaf_1->m_keys[0];
        odd_node.m_keys[1] = odd_leaf_2->m_keys[0];

        _ASSERT(odd_node.erase(50) == true);
        _ASSERT(odd_node.m_key_counter == 2);
        _ASSERT(std::get<1>(odd_node.m_data)[0] == odd_leaf_1);
        _ASSERT(std::get<1>(odd_node.m_data)[1] == odd_leaf_3);
        _ASSERT(odd_leaf_1->m_key_counter == 5);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[0]) == 0);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[1]) == 10);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[2]) == 20);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[3]) == 30);
        _ASSERT(*(std::get<0>(odd_leaf_1->m_data)[4]) == 40);
        _ASSERT(odd_leaf_3->m_key_counter == 3);
        _ASSERT(*(std::get<0>(odd_leaf_3->m_data)[0]) == 60);
        _ASSERT(*(std::get<0>(odd_leaf_3->m_data)[1]) == 70);
        _ASSERT(*(std::get<0>(odd_leaf_3->m_data)[2]) == 80);
        _ASSERT(*(odd_node.search(0)) == 0);
        _ASSERT(*(odd_node.search(10)) == 10);
        _ASSERT(*(odd_node.search(20)) == 20);
        _ASSERT(*(odd_node.search(30)) == 30);
        _ASSERT(*(odd_node.search(40)) == 40);
        _ASSERT(odd_node.search(50) == nullptr);
        odd_node.erase_all();

        _CONCLUDE;
    });

    return 0;
}
